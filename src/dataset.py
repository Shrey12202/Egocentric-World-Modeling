"""Ego4D-like dataset and indexing utilities.

This file defines:

- :class:`Ego4DSequenceInfo` — simple metadata for one sequence (scene)
- :class:`Ego4DSequencesIndex` — scans the root directory and lists sequences
- :class:`Ego4DSequenceDataset` — PyTorch dataset for all frames in one sequence

The goal is to mirror enough of Ego4D's structure that, once you have the
real dataset, you can plug it in with no code changes. For now, the same
API works with a *fake* Ego4D generated by :mod:`prepare_fake_ego4d`.
"""  # noqa: D400

from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional

import numpy as np
from PIL import Image
import torch
from torch.utils.data import Dataset

from dataset_utils import Compose, ResizeShortestEdge, CenterCropSquare, ToTensor01


@dataclass
class Ego4DSequenceInfo:
    """Metadata describing a single egocentric sequence (scene).

    Attributes
    ----------
    sequence_id:
        String identifier (e.g. 'seq_0000' or an Ego4D UID).
    rgb_dir:
        Directory containing RGB frames like 'frame_000000.jpg'.
    poses_path:
        Optional JSON file with per-frame camera pose information.
        The JSON format is intentionally generic; your NeRF code can
        interpret it as needed.
    intrinsics_path:
        Optional JSON file containing a camera intrinsic matrix (3x3).
    """  # noqa: D401

    sequence_id: str
    rgb_dir: Path
    poses_path: Optional[Path] = None
    intrinsics_path: Optional[Path] = None


class Ego4DSequencesIndex:
    """Index all sequences in an Ego4D-like root directory.

    Expected directory structure (simplified):

    .. code-block:: text

        root/
          v1/
            clips/
              <sequence_id>/
                rgb/
                  frame_000000.jpg
                  frame_000001.jpg
                  ...
                poses.json          # optional
                intrinsics.json     # optional

    This class scans the directory once and builds a mapping
    ``sequence_id -> Ego4DSequenceInfo``.
    """  # noqa: D401

    def __init__(self, root: Path | str):
        self.root = Path(root).expanduser().resolve()
        self.version_dir = self.root / "v1"
        self.clips_dir = self.version_dir / "clips"
        if not self.clips_dir.exists():
            raise FileNotFoundError(f"Expected clips dir at {self.clips_dir}")
        self.sequences = self._scan_sequences()

    def _scan_sequences(self) -> Dict[str, Ego4DSequenceInfo]:
        sequences: Dict[str, Ego4DSequenceInfo] = {}
        for seq_dir in sorted(self.clips_dir.glob("*")):
            if not seq_dir.is_dir():
                continue
            rgb_dir = seq_dir / "rgb"
            if not rgb_dir.exists():
                continue
            poses_path = seq_dir / "poses.json"
            intrinsics_path = seq_dir / "intrinsics.json"
            info = Ego4DSequenceInfo(
                sequence_id=seq_dir.name,
                rgb_dir=rgb_dir,
                poses_path=poses_path if poses_path.exists() else None,
                intrinsics_path=intrinsics_path if intrinsics_path.exists() else None,
            )
            sequences[info.sequence_id] = info
        if not sequences:
            raise RuntimeError(f"No sequences found in {self.clips_dir}")
        return sequences

    def list_sequences(self) -> List[str]:
        """Return a list of all available sequence IDs."""  # noqa: D401

        return list(self.sequences.keys())

    def get(self, sequence_id: str) -> Ego4DSequenceInfo:
        """Return :class:`Ego4DSequenceInfo` for the given ID."""  # noqa: D401

        return self.sequences[sequence_id]


class Ego4DSequenceDataset(Dataset):
    """PyTorch dataset over frames from a single Ego4D-like sequence.

    Each item corresponds to a single frame and returns a dictionary:

    - ``'rgb'``: tensor with shape (3, H, W) in [0, 1]
    - ``'pose'``: optional 4x4 pose matrix as a tensor
    - ``'intrinsics'``: optional 3x3 intrinsic matrix tensor
    - ``'frame_idx'``: integer frame index
    - ``'sequence_id'``: string ID of the sequence
    """  # noqa: D401

    def __init__(
        self,
        sequence_info: Ego4DSequenceInfo,
        img_size: int = 128,
        frame_stride: int = 1,
    ):
        self.info = sequence_info
        self.img_size = img_size
        self.frame_stride = max(1, frame_stride)

        self.frame_paths = sorted(self.info.rgb_dir.glob("*.jpg"))
        if not self.frame_paths:
            raise RuntimeError(f"No frames found in {self.info.rgb_dir}")

        # Subsample frames to reduce training cost if needed
        self.frame_paths = self.frame_paths[:: self.frame_stride]

        self.poses = self._load_optional_json(self.info.poses_path)
        self.intrinsics = self._load_optional_json(self.info.intrinsics_path)

        # Simple image preprocessing pipeline
        self.img_transform = Compose(
            [
                ResizeShortestEdge(img_size),
                CenterCropSquare(img_size),
                ToTensor01(),
            ]
        )

    @staticmethod
    def _load_optional_json(path: Optional[Path]) -> Optional[dict]:
        """Load a JSON file if it exists, else return ``None``."""  # noqa: D401

        if path is None or not path.exists():
            return None
        with open(path, "r") as f:
            return json.load(f)

    def __len__(self) -> int:  # noqa: D401
        return len(self.frame_paths)

    def __getitem__(self, idx: int) -> Dict:
        """Return a single frame and its optional pose/intrinsics.

        This method is called by the PyTorch DataLoader when iterating.
        """  # noqa: D401

        frame_path = self.frame_paths[idx]
        img = Image.open(frame_path).convert("RGB")
        img = self.img_transform(img)  # (3, H, W) tensor

        pose = None
        intrinsics = None

        if self.poses is not None:
            # We allow poses to be stored either by string index or with a
            # default entry under key "0".
            pose_arr = np.array(self.poses.get(str(idx), self.poses.get("0", np.eye(4))))
            pose = torch.from_numpy(pose_arr).float()

        if self.intrinsics is not None:
            K_arr = np.array(self.intrinsics.get("K", np.eye(3)))
            intrinsics = torch.from_numpy(K_arr).float()

        return {
            "rgb": img,
            "pose": pose,
            "intrinsics": intrinsics,
            "frame_idx": idx,
            "sequence_id": self.info.sequence_id,
        }
